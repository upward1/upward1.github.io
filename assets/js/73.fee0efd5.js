(window.webpackJsonp=window.webpackJsonp||[]).push([[73],{564:function(v,s,_){"use strict";_.r(s);var t=_(2),a=Object(t.a)({},(function(){var v=this,s=v._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[s("Boxx"),v._v(" "),s("h2",{attrs:{id:"list和map"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#list和map"}},[v._v("#")]),v._v(" List和Map")]),v._v(" "),s("details",{staticClass:"custom-block details"},[s("summary",[v._v("1. 接口和抽象类之间的区别？")]),v._v(" "),s("ol",[s("li",[s("p",[v._v("分别表示的"),s("strong",[v._v("类型不同")])]),v._v(" "),s("p",[v._v("接口："),s("strong",[v._v("interface")]),s("br"),v._v("\n抽象类："),s("strong",[v._v("class")])])]),v._v(" "),s("li",[s("p",[v._v("里面"),s("strong",[v._v("定义的属性修饰符不同")])]),v._v(" "),s("p",[v._v("接口：里面定义的属性默认都是静态的最终变量（public static final）"),s("br"),v._v("\n抽象类：里面定义的属性默认是（default）")])]),v._v(" "),s("li",[s("p",[v._v("里面"),s("strong",[v._v("定义的方法不同")])]),v._v(" "),s("p",[v._v("接口：里面定义的方法默认都是抽象方法（public abstarct）"),s("br"),v._v("\n从 jdk8.0开始 接口里面可以定义普通方法"),s("br"),v._v("\n抽象类：里面既可以定义抽象方法 又可以定义普通方法")])])])]),v._v(" "),s("details",{staticClass:"custom-block details"},[s("summary",[v._v("2. ArrayList和Vector之间的区别？")]),v._v(" "),s("ul",[s("li",[s("p",[s("em",[s("strong",[v._v("Vector")])]),v._v("：同一时间允许单个线程进行访问 效率较低，但是不会出现并发错误"),s("br"),v._v(" "),s("em",[s("strong",[v._v("ArrayList")])]),v._v("：同一时间允许多个线程进行访问 效率较高，但是可能会出现并发错误")])]),v._v(" "),s("li",[s("p",[v._v("从jdk5.0开始 集合的工具类里面提供一个方法("),s("em",[s("strong",[v._v("synchronizedList")])]),v._v(") 可以将线程不安全的ArrayList对象变成线程安全的集合对象，于是Vector渐渐被淘汰")])])])]),v._v(" "),s("details",{staticClass:"custom-block details"},[s("summary",[v._v("3. ArrayList和LinkedList之间的区别？")]),v._v(" "),s("ul",[s("li",[s("p",[s("em",[s("strong",[v._v("ArrayList")])]),v._v("：底层基于"),s("strong",[v._v("数组")]),v._v("实现的")]),v._v(" "),s("p",[v._v("优点：随机访问 遍历查找效率高"),s("br"),v._v("\n缺点：添加/删除元素")])]),v._v(" "),s("li",[s("p",[s("em",[s("strong",[v._v("LinkedList")])]),v._v("：底层基于"),s("strong",[v._v("链表")]),v._v("实现的")]),v._v(" "),s("p",[v._v("优点：添加/删除元素效率高"),s("br"),v._v("\n缺点：随机访问/遍历查找效率低")])]),v._v(" "),s("li",[s("p",[v._v("*：当正常开发的时候 尽量避免使用LinkedList里面的get(下标)方法")])])])]),v._v(" "),s("details",{staticClass:"custom-block details"},[s("summary",[v._v("4. HashMap和Hashtable之间的区别？")]),v._v(" "),s("ol",[s("li",[s("p",[v._v("同步特性不同：")]),v._v(" "),s("ul",[s("li",[s("em",[s("strong",[v._v("HashMap")])]),v._v(" 同一时间允许多个线程进行访问 "),s("strong",[v._v("效率较高")]),v._v("，但是"),s("strong",[v._v("可能会出现并发错误")])]),v._v(" "),s("li",[s("em",[s("strong",[v._v("Hashtable")])]),v._v(" 同一时间允许一个线程进行访问 "),s("strong",[v._v("效率较低")]),v._v("，但是"),s("strong",[v._v("不会出现并发错误")])]),v._v(" "),s("li",[v._v("从jdk5.0开始，集合的工具类里面提供一个方法（"),s("em",[s("strong",[v._v("synchronizedList")])]),v._v("） 可以将线程不安全的HashMap对象变成线程安全的集合对象")])])]),v._v(" "),s("li",[s("p",[v._v("对null的要求不同")]),v._v(" "),s("ul",[s("li",[s("strong",[v._v("HashMap无论主键还是值都可以存放null")]),v._v("，但是由于主键唯一 所以主键只能添加一个null")]),v._v(" "),s("li",[v._v("Hashtable无论主键还是值都不能装null，一旦泛型里面装null 都会触发NullPointerException")])])]),v._v(" "),s("li",[s("p",[v._v("底层分组不同：")]),v._v(" "),s("ul",[s("li",[s("strong",[v._v("HashMap底层数组大小默认为16")]),v._v("，程序员可以随意的定义，但是最终一定是2的n次方数")]),v._v(" "),s("li",[v._v("Hashtable底层数组大小默认为11，程序员可以随意定义")])])]),v._v(" "),s("li",[s("p",[v._v("出现的版本不同")]),v._v(" "),s("ul",[s("li",[s("strong",[v._v("Hashtable：since jdk1.0")])]),v._v(" "),s("li",[s("strong",[v._v("HashMap：since jdk1.2")])])])])])]),v._v(" "),s("details",{staticClass:"custom-block details"},[s("summary",[v._v("5. hashmap 红黑树")]),v._v(" "),s("ul",[s("li",[s("p",[v._v("负载因子，代表了table的填充度有多少，默认是0.75")]),v._v(" "),s("p",[v._v("加载因子存在的原因，还是因为减缓哈希冲突，提高查询效率。如果初始桶为16，等到满16个元素才扩容，某些桶里可能就有不止一个元素了。\n所以加载因子默认为0.75，也就是说大小为16的HashMap，到了第13个元素，就会扩容成32。")])]),v._v(" "),s("li",[s("p",[v._v("为何HashMap的数组长度一定是2的次幂（减少hash碰撞）")]),v._v(" "),s("p",[v._v("扩容时需要重新计算数组索引index = h&(length-1)，需要进行大量的与运算，保证2的次幂，可以保证在进行与运算时，(length-1)的值的二进制所有的位均为1，这种情况下，Index的结果等于hashCode的最后几位。只要输入的hashCode本身符合均匀分布，Hash算法的结果就是均匀的。")])])])]),v._v(" "),s("h2",{attrs:{id:"泛型"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#泛型"}},[v._v("#")]),v._v(" 泛型")]),v._v(" "),s("details",{staticClass:"custom-block details"},[s("summary",[v._v("1. 泛型中的通配符 T，E，K，V，？")]),v._v(" "),s("p",[v._v("本质上这些个都是通配符，没啥区别，换成 A-Z 之间的任何一个 字母都可以。"),s("br"),v._v("\n通常情况下，T，E，K，V，？ 是这样约定的：")]),v._v(" "),s("ul",[s("li",[v._v("？ 表示不确定的 java 类型")]),v._v(" "),s("li",[v._v("T (type) 表示具体的一个java类型")]),v._v(" "),s("li",[v._v("K V (key value) 分别代表java键值中的Key Value")]),v._v(" "),s("li",[v._v("E (element) 代表Element")])]),v._v(" "),s("blockquote",[s("p",[v._v("可参考："),s("a",{attrs:{href:"https://juejin.im/post/5d5789d26fb9a06ad0056bd9#heading-1",target:"_blank",rel:"noopener noreferrer"}},[v._v("掘金"),s("OutboundLink")],1)])])])],1)}),[],!1,null,null,null);s.default=a.exports}}]);